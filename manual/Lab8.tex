\documentclass{article}
\usepackage{graphicx} % new way of doing eps files
\usepackage{listings} % nice code layout
\usepackage[usenames]{color} % color
\definecolor{listinggray}{gray}{0.9}
\definecolor{graphgray}{gray}{0.7}
\definecolor{ans}{rgb}{1,0,0}
\definecolor{blue}{rgb}{0,0,1}
% \Verilog{title}{label}{file}
\newcommand{\Verilog}[3]{
  \lstset{language=Verilog}
  \lstset{backgroundcolor=\color{listinggray},rulecolor=\color{blue}}
  \lstset{linewidth=\textwidth}
  \lstset{commentstyle=\textit, stringstyle=\upshape,showspaces=false}
  \lstset{frame=tb}
  \lstinputlisting[caption={#1},label={#2}]{#3}
}


\author{Madeline Stephens and Michael Hu}
\title{Lab 8: ALU and ALU Control}

\begin{document}
\maketitle

\section{Introduction}

Integral to the execute stage of the MIPS computer, the ALU and ALU control were constructed in Lab 8. A simple way to construct an ALU is to have the module calculate every function possible and then select the function desired by the user with a multiplexer. While wasteful, the method is fast and simple and suitable for lab purposes. Thus, this was the approach taken in Lab 8. Along with the ALU, it was necessary for an ALU control unit to be built. The functions calculated by the ALU were associated with control bits, which were named in "definitions.vh." The ALU controller was built to utilize the ALUOp and function fields to generate these ALU control bits. This module was also generated with simple Verilog code. Test benches were constructed to test the ALU and the ALU control unit. Both of these modules would later be instantiated during the execute stage in Lab 9.


\section{Interface}
The ALU module took in three inputs: two data inputs (A and B) and one control input, $ALU_control$. The two data inputs were acted upon by the ALU and the control input determined the function calculated by the ALU.  A switch case was created using the names given to the ALU control bits in the definitions header file. There was only one output from the ALU (as could be expected), which was the result of the ALU function chosen by the ALU's control input. This output was aptly named ALUresult. 

The ALU control, however, only took in two inputs: ALUOp and funct. These two inputs were used to generated the ALU control bits used by the ALU. These ALU actions were associated with a binary function code. These were named in "definitions.vh." Thus, these names were used to simply the code and make it more readable. The ALU control input generated one output, named $ALU_control$. This output makes up the ALU control bits used by the ALU to determine the action peformed.

Both the ALU and ALU control were later instantiated in the larger iExecute file as a piece of the execute stage.

\section{Design}

Lab 8 focused on building and testing the ALU and ALU control so that it would later be used in the execute stage. When properly wired up, the ALU eventually will take in data from the registers and will output a result to the data memory. The two units built in Lab 8 allow the MIPS computer to interpret and execute arithmetic and logical commands -- a function integral to any computer. 


\section{Implementation}

The ALU was created using an always block and a switch case statement in Verilog. The ALU was built to calculate each function and then use a control input to select the function the user wants. Thus, the switch statement that executed the ALU functions was controlled by the parameter $ALU_contro$l. As mentioned previously, the binary function codes were given names in the definitions Verilog header file for ease of understanding. This can be see in the code in Listing ~\ref{code:ALU} on page~\pageref{code:ALU}. It is important to note that a zero flag was generated using an assign statement. This flag is integral to an ALU as it indicates when the result of an operation is zero. This flag is extremely helpful for troubleshooting and verifying the correct operation of the ALU itself.

Also integral to the ALU are the control bits. The control bits that are taken into the ALU as the 4-bit input $ALU_contro$l were generated by the ALU control unit. Again, this module made use of a switch statement. However, this module required the implementation of a nested case statement. The larger (or outer) switch statement was constructed similarly to the switch statement in the ALU, except it used the 2-bit parameter ALUOp. ALUOp is an opcode associated with a unique ALU action. Based on this opcode, the case statement chooses which ALU control input to output and send to the ALU. While a bit trickier, the nested switch statement was built to process a specific type of instruction opcode, the R-type. The parameter of this switch statement was the 6-bit funct input. This case statement allowed the ALU control unit to differentiate between the R-type commands and to send the ALU the appropriate control bits. The code for the ALU control unit can be found in Listing~\ref{code:alucontrol}.

\Verilog{Verilog code for building an ALU.}{code:ALU}{H:/MIPS-Lab/code/3_execute/ALU.v}
\Verilog{Verilog code for building the ALU control.}{code:alucontrol}{H:/MIPS-Lab/code/2_decode/ALU_control.v}

\section{Test Bench Design}
As could be expected, it was essential to test the operation of both of the modules constructed in Lab 8. Thus, test benches were generated to ensure that the code operated as intended under a variety of test conditions. Various cases were used to test each module and were chosen according to the operation of the unit under test. Typically, the test cases were chosen to ensure that the code operated as intended, even where common errors could likely occur.

The code for the ALu test bench can be found in Listing~\ref{code:alutest}. The test bench for the ALU module was designed to test each of the operations of the ALU: addition, subtraction, AND, OR, NOR, and SLT. Additionally, the test bench ensured that the ALU could take in different values for A and B. The expected values of the tests can be found in the comments and were used to analyze the simulation waveform generated by the test bench.

Similarly, it was vital to test the operation of the ALU control unit. The ALU control unit test ensured that the output $ALU_control$ was consistent with expectations. Thus, various values for ALUOp and func were tested. Again, the expected results of the test cases can be found in the comments in the test bench. The code for the ALU control test bench can be found in Listing~\ref{code:alucontroltest}.


\Verilog{Verilog code for testing an ALU.}{code:alutest}{"H:/MIPS-Lab/code/alu.srcs/alu simset/alu_test.v"}
\Verilog{Verilog code for testing the ALU control.}{code:alucontroltest}{"H:/MIPS-Lab/code/alu.srcs/alu simset/aluControl_test.v"}



\section{Simulation}
The timing diagram for the ALU test can be found in Figure~\ref{fig:alutest}. By studying this figure, it can be verified that the ALU module operated as intended. It can be seen that the outputs align with the expected values indicated in the test bench. Also, it should be noted that no oscillator waveform is present in the simulation waveform. This is attributed to the fact that the ALU operation was not dependent on a clock signal.

The simulation waveform for the ALU control testbench can be found in Figure~\ref{fig:alucontroltest}. When comparing to the expected values, it can be seen that the ALU control output is exactly what is expected. Thus, it can be concluded that the ALU control unit operated as intended.

\begin{figure}
\begin{center}
\caption{Timing diagram for the ALU test.}\label{fig:alutest}
\includegraphics[width=0.9\textwidth]{H:/CompOrgPics/alu_waveform.PNG}
\end{center}
\end{figure}

\begin{figure}
	\begin{center}
		\caption{Timing diagram for the ALU control test.}\label{fig:alucontroltest}
		\includegraphics[width=0.9\textwidth]{H:/CompOrgPics/aluControl_waveform.PNG}
	\end{center}
\end{figure}


\section{Conclusions}
To eventually construct a properly functioning execute stage, it was necessary to build an ALU and ALU control unit. The ALU allows the computer to interpret and execute arithmetic and logical operations. Without the ALU control, the ALU itself would not be able to function. The ALU control is essential to the ALU as it generates the ALU control bits that allow the ALU to determine the proper function and result. Upon writing and simulation test benches for each of the modules, they were found to operate as expected and without any perceived errors. Although the method used to build the ALU is slightly wasteful, it was determined to be simple enough to execute in the lab setting and able to fulfill the necessary operations.

\end{document} 